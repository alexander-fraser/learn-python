# Maze: Depth-First
# Alexander Fraser
# 13 February 2020

# A maze generator using a depth-first algorithm.

"""
Requirements:
- Numpy
- Matplotlib

The maze is generated by:
1. Starting with a complete grid.
2. Removing walls by taking random moves to unvisited cells.
3. Every time the path comes to a dead-end (i.e. all surrounding cells have been visited)
   it backtracks along its path until it reaches a cell with possibilities for further moves.
4. The algorithm stops when it has backtracked to the initial start and there are
   no possibilities at the starting location.

It is called "depth-first" because the algorithm will follow a path as far as
it can (until it reaches a dead-end).

The array M is going to hold the array information for each cell.
The first four coordinates tell if walls exist on those sides
and the fifth indicates if the cell has been visited in the search.
The last coordinate is used to trace how the maze is generated using colour.
M(LEFT, UP, RIGHT, DOWN, CHECK_IF_VISITED, COLOUR)

The output is saved in two formats.
"""

import random
import numpy as np
from matplotlib import pyplot as plt

def main():
    # Default inputs.
    maze_defaults = {}
    maze_defaults['save_maze'] = 'Depth-First Maze 01.png'
    maze_defaults['save_path'] = 'Depth-First Maze 01 - Path.png'
    maze_defaults['num_rows'] = 10
    maze_defaults['num_cols'] = 10
    maze_defaults['colour_on'] = 0
    maze_defaults['colour_incrementer'] = 1
    
    maze_inputs = collect_inputs(maze_defaults)   # Collect inputs from user.
        
    M = generate_depth_first_maze(maze_inputs)   # Run the maze generator.
    generate_maze_image(maze_inputs, M)   # Visualize the maze.
    generate_path_image(maze_inputs, M)   # Visualize the maze as a path.

def collect_inputs(maze_defaults):
    # Collect inputs from the user.
    # This function is not currently set up. It just passes the defaults along.
    maze_inputs = {}

    for key in maze_defaults:
        try:
            maze_inputs[key] = maze_defaults[key]
        except ValueError:
            maze_inputs[key] = maze_defaults[key]

    return maze_inputs

def generate_depth_first_maze(maze_inputs):
    # Generate the maze using a depth-first algorithm.
    # Set up the maze board.
    num_rows = maze_inputs['num_rows']
    num_cols = maze_inputs['num_cols']
    M = np.zeros((num_rows, num_cols, 6), dtype=np.uint8)
    r = int(num_rows / 2)   # Start in the middle, since the first paths tend to be linear.
    c = int(num_cols / 2)
    history = [(r, c)]
    colour_incrementer = maze_inputs['colour_incrementer']
    
    back_track_indicator = False

    while history:   # The history is the stack of visited locations.
        M[r, c, 4] = 1   # Mark this location as visited.

        if back_track_indicator == False:   # Unless we are backtracking, change the colour to mark the path.
            M[r, c, 5] = colour_incrementer
            colour_incrementer += 1
        back_track_indicator = False

        # Check if the adjacent cells are valid for moving to.
        # Cell must be within board and not visited already.
        check = []
        if c > 0 and M[r, c - 1, 4] == 0:
            check.append('L')
        if r > 0 and M[r - 1, c, 4] == 0:
            check.append('U')
        if c < num_cols - 1 and M[r, c + 1, 4] == 0:
            check.append('R')
        if r < num_rows - 1 and M[r + 1, c, 4] == 0:
            check.append('D')

        if len(check):  # If there is a valid cell to move to.
            # Mark the walls between cells as open if we move.
            history.append([r, c])
            move_direction = random.choice(check)
            if move_direction == 'L':
                M[r, c, 0] = 1
                c = c - 1
                M[r, c, 2] = 1
            if move_direction == 'U':
                M[r, c, 1] = 1
                r = r - 1
                M[r, c, 3] = 1
            if move_direction == 'R':
                M[r, c, 2] = 1
                c = c + 1
                M[r, c, 0] = 1
            if move_direction == 'D':
                M[r, c, 3] = 1
                r = r + 1
                M[r, c, 1] = 1
        else:  # If there are no valid cells to move to.
            # retrace one step back in history if no move is possible.
            r, c = history.pop()
            back_track_indicator = True

    # Open the walls at the start and finish.
    M[0, 0, 0] = 1   # Left side of top-left-most cell.
    M[num_rows - 1, num_cols - 1, 2] = 1   # Right side of bottom-right-most cell.

    return M

def generate_maze_image(maze_inputs, M):
    # Generate the image for display. Each cell is 10x10 pixels, with walls being 1 pixel
    # wide on each side (so outside walls are 1 pixel and inner walls are 2 pixels).
    num_rows = maze_inputs['num_rows']
    num_cols = maze_inputs['num_cols']
    ct = 10  # Cell thickness. Must be 3 or greater.
    image = np.zeros((num_rows * ct, num_cols * ct), dtype=np.uint8)
    cell_colour = 255

    for row in range(0, num_rows):
        for col in range(0, num_cols):
            cell_data = M[row, col]
            cell_colour = cell_data[5]   # Used if you want a somewhat traceable path.
            for i in range(ct * row + 1, ct * row + (ct - 1)):
                image[i, range(ct * col + 1, ct * col + (ct - 1))] = cell_colour
            if cell_data[0] == 1: image[range(ct * row + 1, ct * row + (ct - 1)), ct * col] = cell_colour
            if cell_data[1] == 1: image[ct * row, range(ct * col + 1, ct * col + (ct - 1))] = cell_colour
            if cell_data[2] == 1: image[range(ct * row + 1, ct * row + (ct - 1)), ct * col + (ct - 1)] = cell_colour
            if cell_data[3] == 1: image[ct * row + (ct - 1), range(ct * col + 1, ct * col + (ct - 1))] = cell_colour

    plt.imshow(image, cmap='gray', interpolation='none')
    plt.show()
    plt.imsave(maze_inputs['save_maze'], image, cmap='gray')

def generate_path_image(maze_inputs, M):
    # Generate the image of the path for display. Each cell is 11x11 pixels,
    # with the path being 1 pixel thick.
    num_rows = maze_inputs['num_rows']
    num_cols = maze_inputs['num_cols']
    ct = 11   # Cell thickness. Must be 3 or greater.
    cto = int(ct / 2)   # Cell offset.
    image = np.zeros((num_rows * ct, num_cols * ct), dtype=np.uint8)
    cell_colour = 255

    for row in range(0, num_rows):
        for col in range(0, num_cols):
            cell_data = M[row, col]
            cell_colour = cell_data[5]   # Used if you want a somewhat traceable path.
            image[ct * row + cto, ct * col + cto] = cell_colour
            if cell_data[0] == 1: image[ct * row + cto, range(ct * col, ct * col + cto)] = cell_colour
            if cell_data[1] == 1: image[range(ct * row, ct * row + cto), ct * col + cto] = cell_colour
            if cell_data[2] == 1: image[ct * row + cto, range(ct * col + cto + 1, ct * col + ct)] = cell_colour
            if cell_data[3] == 1: image[range(ct * row + cto + 1, ct * row + ct), ct * col + cto] = cell_colour

    plt.imshow(image, cmap='gray', interpolation='none')
    plt.show()
    plt.imsave(maze_inputs['save_path'], image, cmap='gray')

if __name__ == "__main__":
    main()